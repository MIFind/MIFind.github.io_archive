<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kraken架构设计及Kraken_internal</title>
      <link href="2021/02/22/%E6%B7%98%E5%AE%9DKraken%E6%9E%B6%E6%9E%84/"/>
      <url>2021/02/22/%E6%B7%98%E5%AE%9DKraken%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Kraken架构设计及Kraken-internal"><a href="#Kraken架构设计及Kraken-internal" class="headerlink" title="Kraken架构设计及Kraken_internal"></a>Kraken架构设计及Kraken_internal</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>对于一个跨端框架，我们希望的是：</p><ul><li>性能和体验接近原生</li><li>基于前端体系</li><li>可自定义扩展</li><li>可动态发布</li><li>可跨多平台</li><li>多端UI一致性</li><li>开发工具完善</li></ul><h2 id="Kraken机制"><a href="#Kraken机制" class="headerlink" title="Kraken机制"></a>Kraken机制</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/297774/1594352149873-cdc720d8-7fe4-419b-aba6-dcf7c359014d.png?x-oss-process=image%2Fresize%2Cw_746" alt="image.png"></p><ol><li>Kraken的最上层是一个基于W3C标准而构建的DOM API，在下层是所依赖的JS引擎，通过C++构建Bridge与Dart通信。</li><li>C++ Bridge把JS所调用的一些信息，转发到Dart层。</li><li>Dart层通过接收这些信息，下沉到Flutter Render Engine，DOM Render Tree与Render Object进行对齐，实现高效的渲染性能。</li></ol><h2 id="Kraken-internal"><a href="#Kraken-internal" class="headerlink" title="Kraken_internal"></a>Kraken_internal</h2><p>Kraken_internal是用于构建DOM，DOM API，Timer，并代理bridge。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/297774/1594352267593-47c87366-07a8-4b09-b142-e61a530228e0.png?x-oss-process=image%2Fresize%2Cw_746" alt="image.png"></p><p>这是Kraken DOM模型的抽象，提供了和浏览器一样的DOM API，并暴露在JS环境中，JS通过使用DOM API也就是来创建一个DOM树。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/297774/1594352338873-f2ff09a1-816f-499f-84a0-49a4e2f98a75.png?x-oss-process=image%2Fresize%2Cw_746" alt="image.png"></p><p>而构建出这个DOM树并将DOM树信息与API调用给到Dart层进行处理的库就是Kraken_internal。</p><h3 id="Kraken-internal-API"><a href="#Kraken-internal-API" class="headerlink" title="Kraken_internal API"></a>Kraken_internal API</h3><ul><li><p>ES6-promise</p></li><li><p>DOM Api</p><ul><li><p>EventTarget</p></li><li><p>StyleDeclaration</p></li><li><p>Node</p><ul><li><p>TextNode</p></li><li><p>Element</p><ul><li>MediaElement</li><li>CanvasElement</li><li>ImageElement</li><li>IframeELement</li><li>AnimationPlayerElement</li><li>ObjectElement</li><li>AnchorELement</li></ul></li><li><p>Comment</p></li><li><p>Document</p></li></ul></li><li><p>CookieStorage</p></li><li><p>Event</p><ul><li>PromiseEvent</li><li>ErrorEvent</li><li>CustormEvent</li></ul></li><li><p>Network</p><ul><li>matchMedia</li><li>websocket</li><li>fetch</li><li>URL</li><li>location</li><li>navigator</li><li>requestAnimationFrame</li><li>XMLHttpRequest</li><li>Blob</li><li>asyncStorage</li><li>Performance</li><li>MQTT</li><li>methodChannel</li></ul></li><li><p>history</p></li><li><p>window</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>跨端通信难题</title>
      <link href="2021/02/22/%E8%B7%A8%E7%AB%AF%E9%80%9A%E4%BF%A1%E9%9A%BE%E9%A2%98/"/>
      <url>2021/02/22/%E8%B7%A8%E7%AB%AF%E9%80%9A%E4%BF%A1%E9%9A%BE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="跨端通信难题"><a href="#跨端通信难题" class="headerlink" title="跨端通信难题"></a>跨端通信难题</h1><p>对于不同架构生态之间做转化，最主要的是运行时对齐，这就涉及到了数据与视图层的同步，JS与Dart的通信问题是一个优秀架构的出口。</p><h2 id="Js-2-WebView-2-Native"><a href="#Js-2-WebView-2-Native" class="headerlink" title="Js 2 WebView 2 Native"></a>Js 2 WebView 2 Native</h2><p>基于 Android WebView 的体系下可以在 Java 层通过 WebView 提供的接口注入一个 JavaScriptInterface，JS 就可以得到一个扩展的 API，调用的时候经过 V8 最终反射到 Java 上面。</p><p><img src="/images/20210225110444-7np4v72-javascriptInterface_webview.png" alt="javascriptInterfacewebview.png"></p><h2 id="JS-2-Native"><a href="#JS-2-Native" class="headerlink" title="JS 2 Native"></a>JS 2 Native</h2><p>对于使用WebView做中间人，第一是会带来平台相关性的实现；第二是调用路径较长，ReactNative使用了JS2Native的方式，使用了JS Binding 的方案，将原先依赖平台的实现直接下沉到 C++，去实现 JS 对象的扩展。</p><p><img src="/images/20210225110507-spk8c32-js2Native%E9%80%9A%E4%BF%A1.png" alt="js2Native通信.png"></p><h2 id="Flutter通信"><a href="#Flutter通信" class="headerlink" title="Flutter通信"></a>Flutter通信</h2><h3 id="Platform-Channel"><a href="#Platform-Channel" class="headerlink" title="Platform Channel"></a>Platform Channel</h3><p>Flutter 官方提供了一种 Platform Channel 的方案，用于 Dart 和平台之间相互通信。</p><p>主要的原理就是将传递的数据编码成消息的形式，跨线程发送到平台接口层，处理之后再将返回的数据通过同样的方式原路返回。</p><p><em>基于消息和跨线程的处理使得这种方式的通信效率并不高，在骁龙845的机器上测了一组数据，一秒内通过 Platform Channel 只能大概完成四千次左右的相互调用。</em> （数据来源：WX团队）</p><p><img src="/images/20210225110545-snwiplk-platformChannel.png" alt="platformChannel.png"></p><p><img src="/images/20210225110600-ahsy7ly-method_channel%E9%80%9A%E4%BF%A1.png" alt="methodchannel通信.png"></p><h3 id="Dart-FFI"><a href="#Dart-FFI" class="headerlink" title="Dart FFI"></a>Dart FFI</h3><p><a href="https://flutter.cn/docs/development/platform-integration/c-interop" target="_blank" rel="noopener">https://flutter.cn/docs/development/platform-integration/c-interop</a></p><p>官方在beta版推出了dart:ffi ，支持了Flutter通过 <a href="https://api.dart.cn/dev/dart-ffi/dart-ffi-library.html" target="_blank" rel="noopener">dart:ffi</a> 库来调用本地的 C++API。</p><p>既然JS可以和C++ 相互调用，C++又可以和Dart相互调用，他们结合在一起其实就可以间接的打通JavaScript和Dart。</p><p>虽然JavaScript和Dart有各自的执行环境和机制，但通过C++的桥梁依然可以构建一个高效的通道，中间可以通过引用和一些转换（类似JNI）来完成大多数的调用操作和数据传递。</p><p><img src="/images/20210225110620-6ky5ax8-js2dart.png" alt="js2dart.png"></p><p>但这并不是说磨平了Android与IOS平台差异性，不同平台的js engine是不同的，对应的js binding也是差异性的,也可以想办法做到js engine对齐，比如hermes、quickjs。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="2020/07/02/resume/"/>
      <url>2020/07/02/resume/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="高级前端开发工程师"><a href="#高级前端开发工程师" class="headerlink" title="高级前端开发工程师"></a>高级前端开发工程师</h1><ul><li>铉嘉伟/男/1993.2</li><li>本科/中北大学（2011 ~ 2015）</li><li>工作年限：5 年</li><li>手机/微信：17666117715</li><li>Email：<a href="mailto:mifind@sina.com">mifind@sina.com</a></li><li>技术博客：<a href="http://milimili.online" target="_blank" rel="noopener">http://milimili.online</a></li></ul><hr><h2 id="求职意向"><a href="#求职意向" class="headerlink" title="求职意向"></a>求职意向</h2><ul><li>期望职位：高级前端工程师</li><li>期望城市：杭州</li><li>技术栈：Web（React、Vue）、Mobile（React Native）、Node</li></ul><hr><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><h2 id="趣头条-萌推（电商）（2019-年-9-月至今）"><a href="#趣头条-萌推（电商）（2019-年-9-月至今）" class="headerlink" title="趣头条-萌推（电商）（2019 年 9 月至今）"></a>趣头条-萌推（电商）（2019 年 9 月至今）</h2><h3 id="1-萌推商家端-APP（React-Native）"><a href="#1-萌推商家端-APP（React-Native）" class="headerlink" title="1. 萌推商家端 APP（React Native）"></a>1. 萌推商家端 APP（React Native）</h3><ul><li>作为萌推商家 APP 负责人，参与了萌推商家端 APP 的开发，该项目使用 React Native 进行开发，接手以后重构了 RN 版本，并 fork 0.61.5 分支出来 fix 一些版本 bug，达到一周内业务方 BUG 反馈率减少 50%，Crash 上报达到 0.01%以下。完成 RN 热更新平台搭建，热更新服务与原有拆包结合，完成原生改造，项目稳定运行中。</li></ul><h3 id="2-萌掌柜（壳工具）开发工作"><a href="#2-萌掌柜（壳工具）开发工作" class="headerlink" title="2. 萌掌柜（壳工具）开发工作"></a>2. 萌掌柜（壳工具）开发工作</h3><ul><li>萌掌柜是萌推商家 PC 客服工具（类似千牛），主要负责 Electron 壳工具的开发，提供 web 与 PC Native 交互的通用 bridge 能力（截图、通知）。<br>项目为 PC Hybrid，壳、内容分离，为提供加载速度，完成 Electron 项目资源包 SDK。</li></ul><h3 id="3-萌推资源包研发（后台、SDK）"><a href="#3-萌推资源包研发（后台、SDK）" class="headerlink" title="3. 萌推资源包研发（后台、SDK）"></a>3. 萌推资源包研发（后台、SDK）</h3><ul><li>由于全量包 CDN 流量过大，为客户端完成资源包业务的改造，使用 Myer’s diff 与 bsdiff 算法完成资源包拆分与合并的 SDK，并部署了一套客户端资源包增量更新服务，可用于解决 Web 资源包、客户端 APK 资源拆分，大幅减少 CDN 流量。</li></ul><h3 id="4-QTT-RN-统一方案"><a href="#4-QTT-RN-统一方案" class="headerlink" title="4. QTT RN 统一方案"></a>4. QTT RN 统一方案</h3><ul><li>由于多项目想集成 RN 到原有原生项目做快速迭代开发，提供了一套 RN 统一方案，作为 RN 多 bundle 项目创建、拆包、分包热更新，开发者可以实时推送更新，然后客户端应用可以在应用启动时查询更新。借助 CodePush，不需要重新审核和安装应用，就可以解决应用的缺陷和添加新特性。同时平台提供了可视化操作，能进行发布，回滚，灰度发布，图表分析等。</li></ul><h2 id="上海叶道科技有限公司（2018-年-9-月至-2019-年-9-月）"><a href="#上海叶道科技有限公司（2018-年-9-月至-2019-年-9-月）" class="headerlink" title="上海叶道科技有限公司（2018 年 9 月至 2019 年 9 月）"></a>上海叶道科技有限公司（2018 年 9 月至 2019 年 9 月）</h2><h3 id="独立站项目（类似-shopify，已关闭）。"><a href="#独立站项目（类似-shopify，已关闭）。" class="headerlink" title="独立站项目（类似 shopify，已关闭）。"></a>独立站项目（类似 shopify，已关闭）。</h3><ul><li>负责 C 端脚手架研发，主要技术栈是 node+art-template，通过模板引擎动态生成 env 配置，根据不同数据源选择 mixins 注入组件，动态编译组件，动态生成站点主题，对整个站点进行 health check，检测到配置区有信息改动，对项目进行动态编译。</li><li>C 端页面组件细粒度拆分，将原有电商项目重构，页面整体细粒度组件化。</li><li>OMS 端，商品、组合商品上架、下架、物流更新、退换货操作等常规业务开发。</li></ul><h3 id="WhatsmodePay-支付组件"><a href="#WhatsmodePay-支付组件" class="headerlink" title="WhatsmodePay 支付组件"></a>WhatsmodePay 支付组件</h3><ul><li>PayPal、Asiabill、Stripe 等支付平台的聚合支付组件。该支付组件使用 react+redux+webpack 完成。</li></ul><h3 id="Miraco-区块链电商平台"><a href="#Miraco-区块链电商平台" class="headerlink" title="Miraco 区块链电商平台"></a>Miraco 区块链电商平台</h3><ul><li>负责 Miraco 区块链电商平台的开发，Miraco 主要通过通过部署的 ETH 智能合约进行商品唯一性、物流追踪的区块链平台。</li><li>负责 MIRACO WALLET 与米可百宝袋小程序。<ul><li>APP 项目使用 ReactNative 开发（上线 Google Play 与非国内的所有 AppleStore）。</li><li>后端接口与钱包服务(加密、账户生成、通信签名)使用 Node（Web3Util）开发，nginx 配置钱包微服务与智能合约、后端交互。</li><li>完成了微信小程序版本(米可百宝袋) -（mpvue）。</li></ul></li></ul><h2 id="美的集团-（-2017-年-4-月-2018-年-4-月-）"><a href="#美的集团-（-2017-年-4-月-2018-年-4-月-）" class="headerlink" title="美的集团 （ 2017 年 4 月 ~ 2018 年 4 月 ）"></a>美的集团 （ 2017 年 4 月 ~ 2018 年 4 月 ）</h2><h3 id="GIS-基础平台-PCWeb-Vue-ArcGIS-Java"><a href="#GIS-基础平台-PCWeb-Vue-ArcGIS-Java" class="headerlink" title="GIS 基础平台-PCWeb(Vue/ArcGIS/Java)"></a>GIS 基础平台-PCWeb(Vue/ArcGIS/Java)</h3><ul><li>负责 GIS 基础平台后台页面的开发（element-ui + vue），负责地图页面与组件展示与调试。</li></ul><h3 id="盈峰项目管家-App-Android-ReactNative"><a href="#盈峰项目管家-App-Android-ReactNative" class="headerlink" title="盈峰项目管家 App(Android/ReactNative)"></a>盈峰项目管家 App(Android/ReactNative)</h3><ul><li>负责盈峰项目管家 Android 版本与 ReactNative 版本开发。</li></ul><h2 id="平安科技（2015-年-7-月-2017-年-4-月）"><a href="#平安科技（2015-年-7-月-2017-年-4-月）" class="headerlink" title="平安科技（2015 年 7 月 ~ 2017 年 4 月）"></a>平安科技（2015 年 7 月 ~ 2017 年 4 月）</h2><h3 id="口袋银行-信用卡模块（Vue）"><a href="#口袋银行-信用卡模块（Vue）" class="headerlink" title="口袋银行-信用卡模块（Vue）"></a>口袋银行-信用卡模块（Vue）</h3><ul><li>对接口袋银行完成信用卡部分活动页开发工作。</li></ul><h3 id="平安信用卡（ReactNative）"><a href="#平安信用卡（ReactNative）" class="headerlink" title="平安信用卡（ReactNative）"></a>平安信用卡（ReactNative）</h3><ul><li>负责平安信用卡 ReactNative 版本部分模块的开发工作。</li></ul><h3 id="平安信用卡（Android）"><a href="#平安信用卡（Android）" class="headerlink" title="平安信用卡（Android）"></a>平安信用卡（Android）</h3><ul><li>负责卡片激活、密码管理、188 红包、云闪付（NFC）、用户登录、设置、小额免密等 Native 页面的开发。</li></ul><hr><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><ul><li>前端框架：JS 及各种框架们</li><li>跨平台技术框架：ReactNative/Flutter/Taro/mpvue</li><li>移动端：Android/Kotlin</li><li>后端：Node/Java</li><li>数据库相关：SQL/MongoDB</li><li>基础运维：nginx、docker</li><li>版本管理：Git</li><li>主要语言 JS、TS</li></ul><h1 id="技能证书"><a href="#技能证书" class="headerlink" title="技能证书:"></a>技能证书:</h1><p><a href="https://www.freecodecamp.org/mifind/front-end-certification" target="_blank" rel="noopener">Front End Development of FreeCodeCamp</a></p><p>蓝桥杯 Java 组省一</p><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>愿意承担前端、移动端、全栈工程师的工作，渴望加入一个优秀的团队并愿意与其共同成长。感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> resume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative集成到现有原生项目、拆包、热更新</title>
      <link href="2020/06/15/ReactNativeInNative/"/>
      <url>2020/06/15/ReactNativeInNative/</url>
      
        <content type="html"><![CDATA[<h1 id="ReactNative-集成到现有原生项目、拆包、热更新"><a href="#ReactNative-集成到现有原生项目、拆包、热更新" class="headerlink" title="ReactNative 集成到现有原生项目、拆包、热更新"></a>ReactNative 集成到现有原生项目、拆包、热更新</h1><hr><p>如果你正准备从头开始制作一个新的应用，那么 React Native 会是个非常好的选择。但是大多数项目我们已经有一个原生应用，React Native 作为业务 module，集成到原生应用中。我们一个应用中可能有很多 RN 业务模块，那 module 拆包、热更新就尤为重要。</p><h2 id="集成到现有原生项目"><a href="#集成到现有原生项目" class="headerlink" title="集成到现有原生项目"></a>集成到现有原生项目</h2><h3 id="集成到原生项目，首先要安装-RN-开发环境。"><a href="#集成到原生项目，首先要安装-RN-开发环境。" class="headerlink" title="集成到原生项目，首先要安装 RN 开发环境。"></a>集成到原生项目，首先要安装 RN 开发环境。</h3><ol><li><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">搭建 RN 开发环境</a></li><li>由于是集成到现有原生项目，不需要 init 一个新的 RN 项目。<ol><li>获取 RN 项目库，并执行<code>npm install</code>，安装 RN 项目所需要依赖。</li><li>如果没有 RN 项目库，需要同步当前需要集成的 RN 项目的 package.json，并执行<code>npm install</code></li></ol></li></ol><h3 id="1-Android"><a href="#1-Android" class="headerlink" title="1 Android"></a>1 Android</h3><h4 id="1-project-gradle-添加配置"><a href="#1-project-gradle-添加配置" class="headerlink" title="1. project gradle 添加配置"></a>1. project gradle 添加配置</h4><p>在项目的 build.gradle 文件中为 React Native 添加一个 maven 依赖的入口，必须写在 “allprojects” 代码块中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">         &#x2F;&#x2F;rn</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &quot;$rootDir&#x2F;..&#x2F;node_modules&#x2F;react-native&#x2F;android&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url(&quot;$rootDir&#x2F;..&#x2F;node_modules&#x2F;jsc-android&#x2F;dist&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;qtt maven-&gt; codepush</span><br><span class="line">         maven &#123;</span><br><span class="line">            url &quot;http:&#x2F;&#x2F;nexus.qutoutiao.net&#x2F;repository&#x2F;android&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;rn end</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-app-gradle-添加配置"><a href="#2-app-gradle-添加配置" class="headerlink" title="2. app gradle 添加配置"></a>2. app gradle 添加配置</h4><p>在 app 中 build.gradle 文件中添加 React Native 依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;rn</span><br><span class="line">project.ext.react &#x3D; [</span><br><span class="line">        entryFile: &quot;index.js&quot;,</span><br><span class="line">        enableHermes: false,  &#x2F;&#x2F; clean and rebuild if changing</span><br><span class="line">        jsBundleDirRelease: &quot;$buildDir&#x2F;intermediates&#x2F;merged_assets&#x2F;release&#x2F;out&#x2F;index&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">apply from: &quot;..&#x2F;..&#x2F;node_modules&#x2F;react-native&#x2F;react.gradle&quot;</span><br><span class="line"></span><br><span class="line">def enableHermes &#x3D; project.ext.react.get(&quot;enableHermes&quot;, false);</span><br><span class="line"></span><br><span class="line">def jscFlavor &#x3D; &#39;org.webkit:android-jsc:+&#39;</span><br><span class="line"></span><br><span class="line">def safeExtGet(prop, fallback) &#123;</span><br><span class="line">    rootProject.ext.has(prop) ? rootProject.ext.get(prop) : fallback</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;rn end</span><br></pre></td></tr></table></figure><p>添加 gradle 依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;rn</span><br><span class="line">    if (enableHermes) &#123;</span><br><span class="line">        def hermesPath &#x3D; &quot;..&#x2F;..&#x2F;node_modules&#x2F;hermesvm&#x2F;android&#x2F;&quot;;</span><br><span class="line">        debugImplementation files(hermesPath + &quot;hermes-debug.aar&quot;)</span><br><span class="line">        releaseImplementation files(hermesPath + &quot;hermes-release.aar&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        implementation jscFlavor</span><br><span class="line">    &#125;</span><br><span class="line">    implementation &quot;com.facebook.react:react-native:+&quot; &#x2F;&#x2F; From node_modules</span><br><span class="line">    implementation &quot;androidx.swiperefreshlayout:swiperefreshlayout:1.0.0&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里使用手动引入依赖，所以要手动添加。如果auto-link这里不用引用。</span><br><span class="line">    implementation project(&#39;:@react-native-community_masked-view&#39;)</span><br><span class="line">    implementation project(&#39;:react-native-gesture-handler&#39;)</span><br><span class="line">    implementation project(&#39;:react-native-reanimated&#39;)</span><br><span class="line">    implementation project(&#39;:react-native-safe-area-context&#39;)</span><br><span class="line">    implementation project(&#39;:react-native-screens&#39;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; --&gt; codepush</span><br><span class="line">    implementation project(&#39;:@innotechx_react-native-code-push&#39;)</span><br><span class="line">    &#x2F;&#x2F;rn end</span><br></pre></td></tr></table></figure><p>最下面添加 codepush 引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: file(&quot;..&#x2F;..&#x2F;node_modules&#x2F;@innotechx&#x2F;react-native-code-push&#x2F;android&#x2F;codepush.gradle&quot;)</span><br></pre></td></tr></table></figure><p>注意确认 node_modules 所在的目录位置。</p><h4 id="3-settings-gradle-添加配置"><a href="#3-settings-gradle-添加配置" class="headerlink" title="3. settings.gradle 添加配置"></a>3. settings.gradle 添加配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">include &#39;:@innotechx_react-native-code-push&#39;</span><br><span class="line">project(&#39;:@innotechx_react-native-code-push&#39;).projectDir &#x3D; new File(rootProject.projectDir, &#39;..&#x2F;node_modules&#x2F;@innotechx&#x2F;react-native-code-push&#x2F;android&#x2F;app&#39;)</span><br><span class="line"></span><br><span class="line">include &#39;:react-native-gesture-handler&#39;</span><br><span class="line">project(&#39;:react-native-gesture-handler&#39;).projectDir &#x3D; new File(rootProject.projectDir, &#39;..&#x2F;node_modules&#x2F;react-native-gesture-handler&#x2F;android&#39;)</span><br><span class="line"></span><br><span class="line">include &#39;:react-native-reanimated&#39;</span><br><span class="line">project(&#39;:react-native-reanimated&#39;).projectDir &#x3D; new File(rootProject.projectDir, &#39;..&#x2F;node_modules&#x2F;react-native-reanimated&#x2F;android&#39;)</span><br><span class="line"></span><br><span class="line">include &#39;:react-native-safe-area-context&#39;</span><br><span class="line">project(&#39;:react-native-safe-area-context&#39;).projectDir &#x3D; new File(rootProject.projectDir, &#39;..&#x2F;node_modules&#x2F;react-native-safe-area-context&#x2F;android&#39;)</span><br><span class="line"></span><br><span class="line">include &#39;:react-native-screens&#39;</span><br><span class="line">project(&#39;:react-native-screens&#39;).projectDir &#x3D; new File(rootProject.projectDir, &#39;..&#x2F;node_modules&#x2F;react-native-screens&#x2F;android&#39;)</span><br><span class="line"></span><br><span class="line">include &#39;:@react-native-community_masked-view&#39;</span><br><span class="line">project(&#39;:@react-native-community_masked-view&#39;).projectDir &#x3D; new File(rootProject.projectDir, &#39;..&#x2F;node_modules&#x2F;@react-native-community&#x2F;masked-view&#x2F;android&#39;)</span><br></pre></td></tr></table></figure><h4 id="4-AndroidManifest-xml"><a href="#4-AndroidManifest-xml" class="headerlink" title="4. AndroidManifest.xml"></a>4. AndroidManifest.xml</h4><p>1 声明网络权限<br><br><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code></p><p>2 添加开发者菜单<br><br><code>&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;</code></p><p>3 network_security_config.xml(API level 28+)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">  android:networkSecurityConfig&#x3D;&quot;@xml&#x2F;network_security_config&quot;&gt;</span><br><span class="line">&lt;&#x2F;application&gt;</span><br></pre></td></tr></table></figure><p>在<code>/res/xml</code>中添加<code>network_security_config.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">    &lt;base-config cleartextTrafficPermitted&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;network-security-config&gt;</span><br></pre></td></tr></table></figure><h4 id="4-将兜底包放到-assets-目录下"><a href="#4-将兜底包放到-assets-目录下" class="headerlink" title="4. 将兜底包放到 assets 目录下"></a>4. 将兜底包放到 assets 目录下</h4><h4 id="5-根据-demo-改造原生代码"><a href="#5-根据-demo-改造原生代码" class="headerlink" title="5. 根据 demo 改造原生代码"></a>5. 根据 demo 改造原生代码</h4><p>主要为加载 bundle、拆包、热更新的相关实现。</p><ul><li>JsLoaderUtil</li><li>BaseReactActivity</li><li>SpConfig</li></ul><p>对 Application 的改造: 继承 ReactApplication。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MainApplication extends Application implements ReactApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static Application app;</span><br><span class="line"></span><br><span class="line">    private SpConfig sc;</span><br><span class="line"></span><br><span class="line">    private final ReactNativeHost mReactNativeHost &#x3D; new ReactNativeHost(this) &#123;</span><br><span class="line"></span><br><span class="line">        private String moduleId &#x3D; &quot;basic&quot;;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean getUseDeveloperSupport() &#123;</span><br><span class="line">            JsLoaderUtil.jsState.isDev &#x3D; sc.getLoadRuntime();</span><br><span class="line">            return sc.getLoadRuntime();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected List&lt;ReactPackage&gt; getPackages() &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里要添加进去RNPackage</span><br><span class="line">            return new ArrayList&lt;&gt;(Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">                    new MainReactPackage(),</span><br><span class="line">                    new RNCMaskedViewPackage(),</span><br><span class="line">                    new RNGestureHandlerPackage(),</span><br><span class="line">                    new ReanimatedPackage(),</span><br><span class="line">                    new SafeAreaContextPackage(),</span><br><span class="line">                    new RNScreensPackage(),</span><br><span class="line">                    new CodePush(&quot;Xzy1V0cWXWDuh7Bb7HogAraIAJLT4c266bc0c0&quot;, MainApplication.this, this.moduleId, BuildConfig.DEBUG, &quot;http:&#x2F;&#x2F;code-push-server.qutoutiao.net&#x2F;&quot;)</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Nullable</span><br><span class="line">        @Override</span><br><span class="line">        protected String getJSBundleFile() &#123;</span><br><span class="line">            return CodePush.getJSBundleFile(this.moduleId, &quot;basic.android.bundle&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Nullable</span><br><span class="line">        @Override</span><br><span class="line">        protected String getBundleAssetName() &#123;</span><br><span class="line">            return &quot;basic&#x2F;basic.android.bundle&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected String getJSMainModuleName() &#123;</span><br><span class="line">            return &quot;index&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ReactNativeHost getReactNativeHost() &#123;</span><br><span class="line">        return mReactNativeHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        sc &#x3D; new SpConfig(this);</span><br><span class="line">        app &#x3D; this;</span><br><span class="line">        SoLoader.init(this, &#x2F;* native exopackage *&#x2F; false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前实现是基于基类<code>BaseReactActivity</code>，这样加载 RN module 的业务组件只需要继承<code>BaseReactActivity</code>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Business1Activity extends BaseReactActivity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected String getBundleName() &#123;</span><br><span class="line">        return &quot;act_618.android.bundle&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    protected String getMainComponentName() &#123;</span><br><span class="line">        return &quot;act_618&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getModuleId() &#123;</span><br><span class="line">        return &quot;buz_act_618&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 如果 Android 项目的根目录名就是 android，才可以使用自动引用，就不需要 settings.gradle 与 app build.gradle 里做手动引用依赖，相应的 MainApplication 的 add package 也需要修改。</p><p><strong>CodePush 相关</strong>：<a href="https://developer.qutoutiao.net/wiki/#/8/README?id=android" target="_blank" rel="noopener">相关配置参考</a></p><h3 id="2-IOS"><a href="#2-IOS" class="headerlink" title="2 IOS"></a>2 IOS</h3><h4 id="1-Podfile-修改"><a href="#1-Podfile-修改" class="headerlink" title="1. Podfile 修改"></a>1. Podfile 修改</h4><p>将以下 Podfile 内容配置到你的 Podfile 文件里，<code>pod install</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;9.0&#39;</span><br><span class="line">require_relative &#39;..&#x2F;node_modules&#x2F;@react-native-community&#x2F;cli-platform-ios&#x2F;native_modules&#39;</span><br><span class="line"></span><br><span class="line"># target的名字一般与你的项目名字相同</span><br><span class="line">target &#39;reactnative_multibundler&#39; do</span><br><span class="line"></span><br><span class="line">  # &#39;node_modules&#39;目录一般位于根目录中</span><br><span class="line">  # 但是如果你的结构不同，那你就要根据实际路径修改下面的&#96;:path&#96;</span><br><span class="line">  pod &#39;FBLazyVector&#39;, :path &#x3D;&gt; &quot;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;FBLazyVector&quot;</span><br><span class="line">  pod &#39;FBReactNativeSpec&#39;, :path &#x3D;&gt; &quot;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;FBReactNativeSpec&quot;</span><br><span class="line">  pod &#39;RCTRequired&#39;, :path &#x3D;&gt; &quot;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;RCTRequired&quot;</span><br><span class="line">  pod &#39;RCTTypeSafety&#39;, :path &#x3D;&gt; &quot;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;TypeSafety&quot;</span><br><span class="line">  pod &#39;React&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;&#39;</span><br><span class="line">  pod &#39;React-Core&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;&#39;</span><br><span class="line">  pod &#39;React-CoreModules&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;React&#x2F;CoreModules&#39;</span><br><span class="line">  pod &#39;React-Core&#x2F;DevSupport&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;&#39;</span><br><span class="line">  pod &#39;React-RCTActionSheet&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;ActionSheetIOS&#39;</span><br><span class="line">  pod &#39;React-RCTAnimation&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;NativeAnimation&#39;</span><br><span class="line">  pod &#39;React-RCTBlob&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;Blob&#39;</span><br><span class="line">  pod &#39;React-RCTImage&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;Image&#39;</span><br><span class="line">  pod &#39;React-RCTLinking&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;LinkingIOS&#39;</span><br><span class="line">  pod &#39;React-RCTNetwork&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;Network&#39;</span><br><span class="line">  pod &#39;React-RCTSettings&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;Settings&#39;</span><br><span class="line">  pod &#39;React-RCTText&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;Text&#39;</span><br><span class="line">  pod &#39;React-RCTVibration&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;Libraries&#x2F;Vibration&#39;</span><br><span class="line">  pod &#39;React-Core&#x2F;RCTWebSocket&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;&#39;</span><br><span class="line"></span><br><span class="line">  pod &#39;React-cxxreact&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;ReactCommon&#x2F;cxxreact&#39;</span><br><span class="line">  pod &#39;React-jsi&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;ReactCommon&#x2F;jsi&#39;</span><br><span class="line">  pod &#39;React-jsiexecutor&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;ReactCommon&#x2F;jsiexecutor&#39;</span><br><span class="line">  pod &#39;React-jsinspector&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;ReactCommon&#x2F;jsinspector&#39;</span><br><span class="line">  pod &#39;ReactCommon&#x2F;jscallinvoker&#39;, :path &#x3D;&gt; &quot;..&#x2F;node_modules&#x2F;react-native&#x2F;ReactCommon&quot;</span><br><span class="line">  pod &#39;ReactCommon&#x2F;turbomodule&#x2F;core&#39;, :path &#x3D;&gt; &quot;..&#x2F;node_modules&#x2F;react-native&#x2F;ReactCommon&quot;</span><br><span class="line">  pod &#39;Yoga&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;ReactCommon&#x2F;yoga&#39;</span><br><span class="line"></span><br><span class="line">  pod &#39;DoubleConversion&#39;, :podspec &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;third-party-podspecs&#x2F;DoubleConversion.podspec&#39;</span><br><span class="line">  pod &#39;glog&#39;, :podspec &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;third-party-podspecs&#x2F;glog.podspec&#39;</span><br><span class="line">  pod &#39;Folly&#39;, :podspec &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;react-native&#x2F;third-party-podspecs&#x2F;Folly.podspec&#39;</span><br><span class="line"></span><br><span class="line">  pod &#39;CodePush&#39;, :path &#x3D;&gt; &#39;..&#x2F;node_modules&#x2F;@innotechx&#x2F;react-native-code-push&#39;</span><br><span class="line"></span><br><span class="line">  pod &#39;SSZipArchive&#39;</span><br><span class="line"></span><br><span class="line">  use_native_modules!</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="2-将兜底包放到项目里"><a href="#2-将兜底包放到项目里" class="headerlink" title="2. 将兜底包放到项目里"></a>2. 将兜底包放到项目里</h4><h4 id="3-根据-demo-改造原生代码"><a href="#3-根据-demo-改造原生代码" class="headerlink" title="3. 根据 demo 改造原生代码"></a>3. 根据 demo 改造原生代码</h4><p>主要为加载 bundle、拆包、热更新的相关实现。</p><ul><li>ScriptLoadUtil</li><li>ReactController</li><li>RctBridge</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、暴露RCTBridge的executeSourceCode方法，做法为将本项目中的RCTBridge添加到自己的工程</span><br><span class="line"></span><br><span class="line">2、事先加载基础包：</span><br><span class="line"></span><br><span class="line">jsCodeLocation &#x3D; [[NSBundle mainBundle] URLForResource:@&quot;platform.ios&quot; withExtension:@&quot;bundle&quot;];</span><br><span class="line">bridge &#x3D; [[RCTBridge alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                             moduleProvider:nil</span><br><span class="line">                              launchOptions:launchOptions];</span><br><span class="line"></span><br><span class="line">3、加载业务包：</span><br><span class="line"></span><br><span class="line">NSURL *jsCodeLocationBuz &#x3D; [[NSBundle mainBundle] URLForResource:bundleName withExtension:@&quot;bundle&quot;];</span><br><span class="line">  NSError *error &#x3D; nil;</span><br><span class="line">  NSData *sourceBuz &#x3D; [NSData dataWithContentsOfFile:jsCodeLocationBuz.path</span><br><span class="line">                                         options:NSDataReadingMappedIfSafe</span><br><span class="line">                                           error:&amp;error];</span><br><span class="line">  [bridge.batchedBridge executeSourceCode:sourceBuz sync:NO];</span><br><span class="line"></span><br><span class="line">4、创建RCTRootView，并绑定业务代码</span><br><span class="line"></span><br><span class="line">RCTRootView* view &#x3D; [[RCTRootView alloc] initWithBridge:bridge moduleName:moduleName initialProperties:nil];</span><br></pre></td></tr></table></figure><p><strong>CodePush 相关</strong>：<a href="https://developer.qutoutiao.net/wiki/#/8/README?id=ios" target="_blank" rel="noopener">相关配置参考</a></p><hr><h2 id="ReactNative-拆包与多业务开发"><a href="#ReactNative-拆包与多业务开发" class="headerlink" title="ReactNative 拆包与多业务开发"></a>ReactNative 拆包与多业务开发</h2><ol><li><p>创建业务<br><br><code>npm run create</code>会在<code>/src/modules</code>里创建业务模块。</p></li><li><p>开发与 debug<br><br><code>npm run start</code>开启 metro packager，然后在集成好的 Native 项目查看效果（或者打开 RNHybrid Demo 查看效果）</p></li><li><p>打包<br><br>通过<code>npm run bundler</code>打包基础包与业务包。 1. 基础包配置<br></p></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">基础包入口 - basic.js</span><br><span class="line">import React from &#39;react&#39;</span><br><span class="line">import &#123; Text &#125; from &#39;react-native&#39;</span><br><span class="line">import &#39;react-native&#39;</span><br><span class="line">import &#39;mobx&#39;</span><br><span class="line">import &#39;mobx-react&#39;</span><br><span class="line">import &#39;mobx-react-lite&#39;</span><br><span class="line">import &#39;react-native-gesture-handler&#39;</span><br><span class="line">import &#39;react-native-safe-area-context&#39;</span><br><span class="line">import &#39;react-native-reanimated&#39;</span><br><span class="line">import &#39;react-native-screens&#39;</span><br><span class="line"></span><br><span class="line">import &#39;@innotechx&#x2F;react-native-code-push&#39;</span><br><span class="line"></span><br><span class="line">import &#39;@react-native-community&#x2F;masked-view&#39;</span><br><span class="line">import &#39;@react-navigation&#x2F;stack&#39;</span><br><span class="line">import &#39;@react-navigation&#x2F;native&#39;</span><br><span class="line"></span><br><span class="line">const wrap &#x3D; require(&#39;lodash.wrap&#39;)</span><br><span class="line"></span><br><span class="line">Text.render &#x3D; wrap(Text.render, function(func, ...args) &#123;</span><br><span class="line">  const originText &#x3D; func.apply(this, args)</span><br><span class="line">  return React.cloneElement(originText, &#123; allowFontScaling: false &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>基础包会将在入口配置的node_modules相关的引用与全局公共配置到basic.bundle.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: &#39;basic.js&#39;, &#x2F;&#x2F; 模块入口文件名称</span><br><span class="line">  isBase: true, &#x2F;&#x2F; 是否是基础模块</span><br><span class="line">  isAll: false,</span><br><span class="line">  metroConfig: &#39;metro_basic.config.js&#39;, &#x2F;&#x2F; 模块metro 配置文件，这个必须在项目根目录，rn 的 metro 只读取根目录文件</span><br><span class="line">  bundleName: &#123;</span><br><span class="line">    android: &#39;basic.android.bundle&#39;, &#x2F;&#x2F; 输出名称</span><br><span class="line">    ios: &#39;basic.bundle&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>2. 业务包业务包配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: &#39;buz_act_618.js&#39;, &#x2F;&#x2F; 模块入口文件名称</span><br><span class="line">  isBase: false, &#x2F;&#x2F; 是否是基础模块</span><br><span class="line">  metroConfig: &#39;metro_buz.config.js&#39;,</span><br><span class="line">  bundleName: &#123;</span><br><span class="line">    android: &#39;act_618.android.bundle&#39;,</span><br><span class="line">    ios: &#39;act_618.bundle&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></code></pre><p>通过 npm run bundler 打包会在 bundles 路径生成相应 bundle.</p><ol start="4"><li>上传包到平台<ol><li><code>npm run bundler:upload</code></li><li>CI/CD（待完善）</li></ol></li></ol><p><strong>大前端 RN 平台</strong><br><a href="http://fe-qa.qttcs3.cn/" target="_blank" rel="noopener">测试</a><br><a href="http://fe.qutoutiao.net/" target="_blank" rel="noopener">生产</a></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>跨平台开发指北</title>
      <link href="2020/05/28/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%8C%87%E5%8C%97/"/>
      <url>2020/05/28/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<h1 id="跨平台APP开发实践（RN、Flutter）"><a href="#跨平台APP开发实践（RN、Flutter）" class="headerlink" title="跨平台APP开发实践（RN、Flutter）"></a>跨平台APP开发实践（RN、Flutter）</h1><hr><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p><code>跨平台的优势</code>：</p><blockquote><ul><li><code>真正的原生应用</code>：产生的不是网页应用，不是混合应用，而是一个原生的移动应用。</li><li><code>快速开发应用</code>：相比原生漫长的编译过程，Hot Reload简直不要太爽。</li><li><code>可随时呼叫原生外援</code>：完美兼容Java/Swift/OC的组件，一部分用原生一部分用RN来做完全可以。</li><li><code>跨平台</code>：一套业务逻辑代码可以稳定运行在两个平台。</li><li><code>节省劳动力</code>：为企业节省劳动力。。。（不知道算不算好事儿）。</li></ul></blockquote><ul><li><h5 id="使用Flutter的应用：闲鱼、美团B端、阿里（FlutterGo、AliFlutter、淘宝特价版）、字节（今日头条、西瓜视频、皮皮虾）"><a href="#使用Flutter的应用：闲鱼、美团B端、阿里（FlutterGo、AliFlutter、淘宝特价版）、字节（今日头条、西瓜视频、皮皮虾）" class="headerlink" title="使用Flutter的应用：闲鱼、美团B端、阿里（FlutterGo、AliFlutter、淘宝特价版）、字节（今日头条、西瓜视频、皮皮虾）"></a>使用Flutter的应用：闲鱼、美团B端、阿里（FlutterGo、AliFlutter、淘宝特价版）、字节（今日头条、西瓜视频、皮皮虾）</h5></li><li><h5 id="使用React-Native的应用：携程、美团C端、字节（今日头条）、手机QQ、FaceBook"><a href="#使用React-Native的应用：携程、美团C端、字节（今日头条）、手机QQ、FaceBook" class="headerlink" title="使用React Native的应用：携程、美团C端、字节（今日头条）、手机QQ、FaceBook"></a>使用React Native的应用：携程、美团C端、字节（今日头条）、手机QQ、FaceBook</h5></li></ul><p>可以看出RN和Flutter还是呈五五开的发展态势。<br>github：</p><ul><li><a href="https://github.com/facebook/react-native" target="_blank" rel="noopener">react-native</a></li><li><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">flutter</a></li></ul><p>但是Flutter是在18年底才发行了以第一个稳定版，而React Native是15年就已经推出。这么一看，Flutter突然🔥起来，就1年的时间就挤掉了RN的大半市场，今天我们一起看一下，这两个跨平台的框架究竟有什么神奇的地方。</p><hr><h2 id="1-React-Native的入门与实践"><a href="#1-React-Native的入门与实践" class="headerlink" title="1. React Native的入门与实践"></a>1. React Native的入门与实践</h2><p>React Native是带着React的光环出生的一个跨平台框架，具备React的一切新特性，让从Ionic与HBuilder的时代走过的Hybrid的开发欲罢不能。因为他能通过React的代码与通用的业务逻辑，编写一套完全原生的App应用，而且APP的使用感受与OC/JAVA编写的Native APP完全一致。</p><h3 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1. 搭建环境"></a>1. 搭建环境</h3><ul><li>node</li><li>watchman: 监视文件并且记录文件的改动情况。</li><li>Android环境：<ul><li>JDK</li><li>Android Studio → Android SDK/Gradle/Android SDK Build-Tools</li></ul></li><li>IOS环境:<ul><li>Xcode</li><li>CocoaPods</li></ul></li></ul><h3 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2. 创建应用"></a>2. 创建应用</h3><p><code>react-native init demo</code></p><h3 id="3-写法与代码结构"><a href="#3-写法与代码结构" class="headerlink" title="3. 写法与代码结构"></a>3. 写法与代码结构</h3><p>React Native和React的基本业务逻辑与项目结构是相通的，除了组件是从react-native的包里引用，样式是css的子集，其他的都是页面的生命周期，渲染逻辑，diff都与React无异。</p><p><a href="http://git.innotechx.com/projects/X/repos/mms-rn/browse" target="_blank" rel="noopener">萌推商家APP代码</a></p><p>Android/IOS目录分别承载这各自应用架构与bundle入口，src部分会打包成jsbundle，然后通过Native的入口注入。</p><ul><li>打开AS与Xcode查看一下对应平台代码</li></ul><h3 id="4-RN的运行机制"><a href="#4-RN的运行机制" class="headerlink" title="4.RN的运行机制"></a>4.RN的运行机制</h3><p>看到这里会有这样的一个疑问<code>为什么js代码可以运行在APP中？</code></p><blockquote><p>是因为RN有两个核心</p></blockquote><ul><li>JSC引擎：1 → 因为RN的包里一个有JS执行引擎（WebKit的内核JavaScriptCore），所以它可以运行js代码。（前期是JSC的环境，在0.60.x之后添加了Hermes作为js引擎）。<blockquote></blockquote><a href="https://cloud.tencent.com/developer/article/1492194" target="_blank" rel="noopener">干货 | 加载速度提升15%，携程对RN新一代JS引擎Hermes的调研</a><blockquote></blockquote><a href="https://sourcegraph.com/github.com/facebook/react-native@0.30-stable/-/blob/ReactCommon/cxxreact/JSCExecutor.cpp#L24:11" target="_blank" rel="noopener">React Native JSC源码</a><blockquote></blockquote></li><li>JSI通信：其实就是JSBridge，作为JS与Native的桥梁，运行在JSC环境下，通过C++实现的Native类的代理对象，这样就可以实现JS与Native通信。</li></ul><p>所以：JSC/Hermes会将作为JS的运行环境（解释器），JS层通过JSI获取到对应的C++层的module对象的代理，最终通过JNI回调Java层的module，在通过JNI映射到Native的函数。</p><p><a href="https://sourcegraph.com/github.com/facebook/react-native@v0.63.0-rc.1/-/tree/ReactAndroid/src/main/java/com/facebook/react/views/text" target="_blank" rel="noopener">RN Native Android Module源码</a></p><p><a href="https://sourcegraph.com/github.com/facebook/react-native@v0.63.0-rc.1/-/blob/React/Views/RCTView.m" target="_blank" rel="noopener">RN Native IOS Module源码</a></p><p>所以，RN中所有的标签其实都不是真是的控件，js代码中所有的控件，都是一个“Map对中的key”，JS通过这个key组合的DOM，放到VDOM的js数据结构中，然后通过JSBridge代理到Native，Native端会解析这个DOM，从而获得对应的Native的控件。</p><h3 id="5-怎么实现一个Native-Bridge的功能。（先不讲）"><a href="#5-怎么实现一个Native-Bridge的功能。（先不讲）" class="headerlink" title="5.怎么实现一个Native Bridge的功能。（先不讲）"></a>5.怎么实现一个Native Bridge的功能。（先不讲）</h3><blockquote><p>例子：实现判断应用是否开启通知，如果未打开通知则进入设置页面开启通知。</p></blockquote><p>5.1 <code>IOS端</code></p><ul><li>IOS在 React Native 中，一个“原生模块”就是一个实现了“RCTBridgeModule”协议的 Objective-C 类。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &lt;React&#x2F;RCTEventEmitter.h&gt;</span><br><span class="line"></span><br><span class="line">@interface RNDataTransferManager : RCTEventEmitter &lt;RCTBridgeModule&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;RNDataTransferManager.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation RNDataTransferManager</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_MODULE();</span><br><span class="line">&#x2F;&#x2F; 判断notification是否开启</span><br><span class="line">RCT_EXPORT_METHOD(isNotificationEnabled:(RCTPromiseResolveBlock)resolve</span><br><span class="line">                  rejecter:(RCTPromiseRejectBlock)reject) &#123;</span><br><span class="line">  BOOL isEnable &#x3D; NO;</span><br><span class="line">  UIUserNotificationSettings *setting &#x3D; [[UIApplication sharedApplication] currentUserNotificationSettings];</span><br><span class="line">  isEnable &#x3D; (UIUserNotificationTypeNone &#x3D;&#x3D; setting.types) ? NO : YES;</span><br><span class="line">  return resolve(@(isEnable));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 进入设置开启Notification</span><br><span class="line">RCT_EXPORT_METHOD(gotoOpenNotification) &#123;</span><br><span class="line">  [self goToAppSystemSetting];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意两个宏：</p><p><code>RCT_EXPORT_METHOD</code>：用来设置给JS导出的Native Module名字。</p><p><code>RCT_EXPORT_MODULE</code>：给JS提供的方法通过<code>RCT_EXPORT_METHOD()</code>宏实现，必须明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。</p><p>5.2 <code>Android端</code></p><p>首先新建一个JavaModule类继承ReactContextBaseJavaModule。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class RNDataTransferManager extends ReactContextBaseJavaModule &#123;</span><br><span class="line"></span><br><span class="line">    private static ReactApplicationContext reactContext;</span><br><span class="line"></span><br><span class="line">    public static RNDataTransferManager rnDataTransferManager;</span><br><span class="line"></span><br><span class="line">    public static String currentBindAlias &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public RNDataTransferManager(@Nonnull ReactApplicationContext reactContext) &#123;</span><br><span class="line">        super(reactContext);</span><br><span class="line">        this.reactContext &#x3D; reactContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RNDataTransferManager getInstance() &#123;</span><br><span class="line">        if (null &#x3D;&#x3D; rnDataTransferManager) &#123;</span><br><span class="line">            rnDataTransferManager &#x3D; new RNDataTransferManager(reactContext);</span><br><span class="line">        &#125;</span><br><span class="line">        return rnDataTransferManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nonnull</span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;RNDataTransferManager&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        @ReactMethod</span><br><span class="line">    public void isNotificationEnabled(Promise promise) &#123;</span><br><span class="line">        if (promise !&#x3D; null) &#123;</span><br><span class="line">            if (MainApplication.getContext() !&#x3D; null) &#123;</span><br><span class="line">                if (NotificationManagerCompat.from(MainApplication.getContext())</span><br><span class="line">                        .areNotificationsEnabled()) &#123;</span><br><span class="line">                    Log.e(&quot;push&quot;, &quot;推送开启 isNotificationEnabled -&gt; true&quot;);</span><br><span class="line">                    promise.resolve(true);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.e(&quot;push&quot;, &quot;推送未开启 isNotificationEnabled -&gt; false&quot;);</span><br><span class="line">                    promise.resolve(false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                promise.resolve(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ReactMethod</span><br><span class="line">    public boolean gotoOpenNotification() &#123;</span><br><span class="line">        if (MainApplication.getContext() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Intent intent &#x3D; getSetIntent(MainApplication.getContext());</span><br><span class="line">        PackageManager packageManager &#x3D; MainApplication.getContext().getPackageManager();</span><br><span class="line">        List&lt;ResolveInfo&gt; list &#x3D; packageManager.queryIntentActivities(intent, 0);</span><br><span class="line">        if (list !&#x3D; null &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                MainApplication.getContext().startActivity(intent);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好了Native Module之后需要注册模块。</p><p>1）首先通过ReactPackage的createNativeModules来注册模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.mengtuiapp.mms.bridge;</span><br><span class="line"></span><br><span class="line">import com.facebook.react.ReactPackage;</span><br><span class="line">import com.facebook.react.bridge.NativeModule;</span><br><span class="line">import com.facebook.react.bridge.ReactApplicationContext;</span><br><span class="line">import com.facebook.react.uimanager.ViewManager;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Nonnull;</span><br><span class="line"></span><br><span class="line">public class DataTransferPackage implements ReactPackage &#123;</span><br><span class="line"></span><br><span class="line">    private RNDataTransferManager transferModule;</span><br><span class="line"></span><br><span class="line">    @Nonnull</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;NativeModule&gt; createNativeModules(@Nonnull ReactApplicationContext reactContext) &#123;</span><br><span class="line">        List&lt;NativeModule&gt; nativeModules &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        transferModule &#x3D; new RNDataTransferManager(reactContext);</span><br><span class="line">        RNDataTransferManager.rnDataTransferManager &#x3D; transferModule;</span><br><span class="line">        nativeModules.add(transferModule);</span><br><span class="line">        return nativeModules;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nonnull</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;ViewManager&gt; createViewManagers(@Nonnull ReactApplicationContext reactContext) &#123;</span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）然后让你的应用拿到注册到的package，需要在Application的getPackages方法中提供。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected List&lt;ReactPackage&gt; getPackages() &#123;</span><br><span class="line">                 List&lt;ReactPackage&gt; packages &#x3D; new PackageList(this).getPackages();</span><br><span class="line">                 packages.add(new DataTransferPackage());</span><br><span class="line">                 packages.add(new RNInstallApkPackage());</span><br><span class="line">                 packages.add(new RNUserAgentPackage());</span><br><span class="line">                 packages.add(new RNKeyboardAdjustPackage());</span><br><span class="line">                 packages.add(new CodePush(mContext.getString(R.string.InnotechCodepushKey), mContext, this.moduleId, BuildConfig.DEBUG, mContext.getString(R.string.InnotechCodepushServerUrl)));</span><br><span class="line">                 return packages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.3 JS端调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NativeModules.RNDataTransferManager.gotoOpenNotification()</span><br><span class="line">就可以前往应用设置页面打开通知。</span><br></pre></td></tr></table></figure><ul><li>当然我们实际开发中不会围绕这么多Native Module来做文章，但是可以看出，做RN是需要一个基本的原生的操作能力。</li></ul><h3 id="6-这样做的优势和问题"><a href="#6-这样做的优势和问题" class="headerlink" title="6. 这样做的优势和问题"></a>6. 这样做的优势和问题</h3><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><blockquote><ul><li>相比Hybrid性能更高、因为都是原生组件的渲染。</li><li>从render到virtual dom的过程都是React驱动，具备React的一切优秀特性，可以使用React的社区优秀工具。</li><li>项目搭建起来了，用JS写APP又具有原生的渲染效率简直爽，一份代码Android、IOS、web都可以适配（毕竟vDom层是一样的，jsbridge就随你魔改了）。</li><li>相比原生的编译速度，开发JS使用HotReload简直太爽了。</li></ul></blockquote><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><blockquote><ul><li>跨平台，但是Android、IOS毕竟是不同的系统与生态，组件与功能都有一些跨平台的差异，RN的原生组件的平台差异性很大。</li><li>性能问题：动画性能不好、列表数据量大性能不好，主要集中在低端机，大数据列表快速滑动会有白屏，动画层级多在Android低于30fps的情况频繁。</li><li>白屏问题，加载bundle的时间会有一个白屏出现，需要手动改Native代码。</li><li>开发业务功能不需要原生能力，但是开发一个完整的跨平台项目，是需要具备一定的双端原生能力（有很多要写Native的，许多功能和组件也需要自己封装）</li><li>这也是RN做的不好的地方，版本迭代太慢，不痛不痒的迭代了5年了，很多问题还是没有解决。这也是Flutter为什么这么火的原因。</li></ul></blockquote><h3 id="7-那么Flutter怎么做的"><a href="#7-那么Flutter怎么做的" class="headerlink" title="7. 那么Flutter怎么做的"></a>7. 那么Flutter怎么做的</h3><p>Flutter使用Dart作为开发语言，作为一个AOT框架，Flutter是在运行时直接将Dart转化成客户端的可执行文件，然后通过Skia渲染引擎直接渲染到硬件平台。如果说RN是为开发者做了平台兼容，那Flutter更像是为开发者屏蔽了平台的概念。RN需要被转译为本地对应的组件，而Flutter是直接编译成可执行文件并渲染到设备。Flutter可以直接控制屏幕上的每一个像素，这样就可以避免由于使用JSBridge导致的性能问题。</p><blockquote></blockquote><p>三要素：</p><blockquote></blockquote><ul><li>Dart语言开发。</li><li>任何Dart代码都是AOT运行前编译成本地可执行文件，使用Skia（渲染引擎）直接渲染到本机。</li><li>不使用原生的组件，具有自己的widget库，开发时构建自己的widget树来画页面。</li></ul><h5 id="如果是页面级的应用来说，Flutter是不需要任何原生代码来写组件，所有组件和页面都可以通过Flutter直接写好。"><a href="#如果是页面级的应用来说，Flutter是不需要任何原生代码来写组件，所有组件和页面都可以通过Flutter直接写好。" class="headerlink" title="如果是页面级的应用来说，Flutter是不需要任何原生代码来写组件，所有组件和页面都可以通过Flutter直接写好。"></a>如果是页面级的应用来说，Flutter是不需要任何原生代码来写组件，所有组件和页面都可以通过Flutter直接写好。</h5><h4 id="7-1-Flutter代码结构"><a href="#7-1-Flutter代码结构" class="headerlink" title="7.1 Flutter代码结构"></a>7.1 Flutter代码结构</h4><p><a href="https://gitlab.innotechx.com/xuanjiawei/flutter_mms_app" target="_blank" rel="noopener">萌推商家APP Flutter版本</a></p><h4 id="7-2-Flutter运行与调试"><a href="#7-2-Flutter运行与调试" class="headerlink" title="7.2 Flutter运行与调试"></a>7.2 Flutter运行与调试</h4><p>直接演示。</p><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>今天我们主要看了一下两个框架开发时的代码结构，与代码书写形式，还有简单了解了一下它是怎么运行。那之后如果小伙伴想继续去学习，或做一个自己的应用，还有以下几个方面需要注意：</p><pre><code>1. APP初始化与生命周期状态。2. 数据持久化 - 数据管理、SP、本地数据库。3. 碎片化处理。4. 打包三要素：Android（混淆、签名、加固），IOS（生成证书、导入证书、使用证书）。5. 拆包、热更新、原生集成。</code></pre><p>Flutter因为自带了渲染引擎，理论上是要比RN渲染效率要高，但是其实实际使用上，在性能过剩的移动端设备中，并没有出现特别大的差异，而Facebook的团队在Flutter的持续施压之下也决定重构底层，并在最近几个版本有了一些进步，所以大家有兴趣的都可以研究一下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mobx使用指北</title>
      <link href="2019/08/15/mobx/"/>
      <url>2019/08/15/mobx/</url>
      
        <content type="html"><![CDATA[<p><strong>MobX 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。</strong></p><p>MobX 背后的哲学很简单：<strong>任何源自应用状态的东西都应该自动地获得。</strong></p><p>其中包括 UI、数据序列化、服务器通讯，等等。</p><p>React 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而 MobX 提供机制来存储和更新应用状态供 React 使用。</p><p>对于应用开发中的常见问题，React 和 MobX 都提供了最优和独特的解决方案。React 提供了优化 UI 渲染的机制， 这种机制就是通过使用虚拟 DOM 来减少昂贵的 DOM 变化的数量。MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="1-Observable-state-可观察的状态"><a href="#1-Observable-state-可观察的状态" class="headerlink" title="1. Observable state(可观察的状态)"></a>1. Observable state(可观察的状态)<br></h4><p>MobX 为现有的数据结构(如对象，数组和类实例)添加了可观察的功能。 通过使用 @observable 装饰器(ES.Next)来给你的类属性添加注解就可以简单地完成这一切。</p><h4 id="2-Computed-value-计算值"><a href="#2-Computed-value-计算值" class="headerlink" title="2. Computed value(计算值)"></a>2. Computed value(计算值)</h4><p>使用 MobX， 你可以定义在相关数据发生变化时自动更新的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class TodoList &#123;</span><br><span class="line">    @observable todos &#x3D; [];</span><br><span class="line">    @computed get unfinishedTodoCount() &#123;</span><br><span class="line">        return this.todos.filter(todo &#x3D;&gt; !todo.finished).length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当添加了一个新的 todo 或者某个 todo 的 finished 属性发生变化时，MobX 会确保 unfinishedTodoCount 自动更新。 像这样的计算可以类似于 MS Excel 这样电子表格程序中的公式。每当只有在需要它们的时候，它们才会自动更新。</p><h4 id="3-Reactions-反应"><a href="#3-Reactions-反应" class="headerlink" title="3. Reactions(反应)"></a>3. Reactions(反应)</h4><p>Reactions 和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新 React 组件树以修补 DOM、等等。</p><h5 id="React"><a href="#React" class="headerlink" title="React"></a>React</h5><p>如果你用 React 的话，可以把你的(无状态函数)组件变成响应式组件，方法是在组件上添加 observer 函数/ 装饰器. observer 由 mobx-react 包提供的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123;observer&#125; from &#39;mobx-react&#39;;</span><br><span class="line"></span><br><span class="line">@observer</span><br><span class="line">class TodoListView extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;this.props.todoList.todos.map(todo &#x3D;&gt;</span><br><span class="line">                    &lt;TodoView todo&#x3D;&#123;todo&#125; key&#x3D;&#123;todo.id&#125; &#x2F;&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">            Tasks left: &#123;this.props.todoList.unfinishedTodoCount&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const TodoView &#x3D; observer((&#123;todo&#125;) &#x3D;&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">            type&#x3D;&quot;checkbox&quot;</span><br><span class="line">            checked&#x3D;&#123;todo.finished&#125;</span><br><span class="line">            onClick&#x3D;&#123;() &#x3D;&gt; todo.finished &#x3D; !todo.finished&#125;</span><br><span class="line">        &#x2F;&gt;&#123;todo.title&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const store &#x3D; new TodoList();</span><br><span class="line">ReactDOM.render(&lt;TodoListView todoList&#x3D;&#123;store&#125; &#x2F;&gt;, document.getElementById(&#39;mount&#39;));</span><br></pre></td></tr></table></figure><h5 id="自定义-reactions"><a href="#自定义-reactions" class="headerlink" title="自定义 reactions"></a>自定义 reactions</h5><p>使用 autorun、reaction 和 when 函数即可简单的创建自定义 reactions，以满足你的具体场景。</p><p>例如，每当 unfinishedTodoCount 的数量发生变化时，下面的 autorun 会打印日志消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">autorun(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;Tasks left: &quot; + todos.unfinishedTodoCount)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Actions-动作"><a href="#Actions-动作" class="headerlink" title="Actions(动作)"></a>Actions(动作)</h4><p>不同于 flux 系的一些框架，MobX 对于如何处理用户事件是完全开明的。</p><p>可以用类似 Flux 的方式完成<br>或者使用 RxJS 来处理事件<br>或者用最直观、最简单的方式来处理事件，正如上面演示所用的 onClick<br>最后全部归纳为: 状态应该以某种方式来更新。</p><p>当状态更新后，MobX 会以一种高效且无障碍的方式处理好剩下的事情。像下面如此简单的语句，已经足够用来自动更新用户界面了。</p><p>从技术上层面来讲，并不需要触发事件、调用分派程序或者类似的工作。归根究底 React 组件只是状态的华丽展示，而状态的衍生由 MobX 来管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">store.todos.push(</span><br><span class="line">    new Todo(&quot;Get Coffee&quot;),</span><br><span class="line">    new Todo(&quot;Write simpler code&quot;)</span><br><span class="line">);</span><br><span class="line">store.todos[0].finished &#x3D; true;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MobX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器 Decorator</title>
      <link href="2019/07/25/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>2019/07/25/%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器是一种函数，写成@ + 函数名。它可以放在类和类方法的定义前面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@frozen class Foo &#123;</span><br><span class="line">  @configurable(false)</span><br><span class="line">  @enumerable(true)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @throttle(500)</span><br><span class="line">  expensiveMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。</p><h3 id="1-类的装饰"><a href="#1-类的装饰" class="headerlink" title="1. 类的装饰"></a>1. 类的装饰</h3><p>装饰器可以用来装饰整个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function testable(target) &#123;</span><br><span class="line">  target.isTestable &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>基本上，装饰器的行为就是下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line"></span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A &#x3D; decorator(A) || A;</span><br></pre></td></tr></table></figure><p>也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function testable(target) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，testable 函数的参数 target，就是会被装饰的类。</p><p>如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function testable(isTestable) &#123;</span><br><span class="line">  return function(target) &#123;</span><br><span class="line">    target.isTestable &#x3D; isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(true)</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line">MyTestableClass.isTestable &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">@testable(false)</span><br><span class="line">class MyClass &#123;&#125;</span><br><span class="line">MyClass.isTestable &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>上面代码中，装饰器 testable 可以接受参数，这就等于可以修改装饰器的行为。</p><p>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</p><p>前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的 prototype 对象操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function testable(target) &#123;</span><br><span class="line">  target.prototype.isTestable &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;&#125;</span><br><span class="line"></span><br><span class="line">let obj &#x3D; new MyTestableClass();</span><br><span class="line">obj.isTestable &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>上面代码中，装饰器函数 testable 是在目标类的 prototype 对象上添加属性，因此就可以在实例上调用。</p><h3 id="2-方法的装饰"><a href="#2-方法的装饰" class="headerlink" title="2.方法的装饰"></a>2.方法的装饰</h3><p>装饰器不仅可以装饰类，还可以装饰类的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; return &#96;$&#123;this.first&#125; $&#123;this.last&#125;&#96; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，装饰器 readonly 用来装饰“类”的 name 方法。</p><p>装饰器函数 readonly 一共可以接受三个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function readonly(target, name, descriptor)&#123;</span><br><span class="line">  &#x2F;&#x2F; descriptor对象原来的值如下</span><br><span class="line">  &#x2F;&#x2F; &#123;</span><br><span class="line">  &#x2F;&#x2F;   value: specifiedFunction,</span><br><span class="line">  &#x2F;&#x2F;   enumerable: false,</span><br><span class="line">  &#x2F;&#x2F;   configurable: true,</span><br><span class="line">  &#x2F;&#x2F;   writable: true</span><br><span class="line">  &#x2F;&#x2F; &#125;;</span><br><span class="line">  descriptor.writable &#x3D; false;</span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, &#39;name&#39;, descriptor);</span><br><span class="line">&#x2F;&#x2F; 类似于</span><br><span class="line">Object.defineProperty(Person.prototype, &#39;name&#39;, descriptor);</span><br></pre></td></tr></table></figure><p>装饰器第一个参数是类的原型对象，上例是 Person.prototype，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时 target 参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。</p><p>另外，上面代码说明，装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</p><p>下面是另一个例子，修改属性描述对象的 enumerable 属性，使得该属性不可遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  @nonenumerable</span><br><span class="line">  get kidCount() &#123; return this.children.length; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function nonenumerable(target, name, descriptor) &#123;</span><br><span class="line">  descriptor.enumerable &#x3D; false;</span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的@log 装饰器，可以起到输出日志的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Math &#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function log(target, name, descriptor) &#123;</span><br><span class="line">  var oldValue &#x3D; descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value &#x3D; function() &#123;</span><br><span class="line">    console.log(&#96;Calling $&#123;name&#125; with&#96;, arguments);</span><br><span class="line">    return oldValue.apply(this, arguments);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const math &#x3D; new Math();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; passed parameters should get logged now</span><br><span class="line">math.add(2, 4);</span><br></pre></td></tr></table></figure><p>上面代码中，@log 装饰器的作用就是在执行原始的操作之前，执行一次 console.log，从而达到输出日志的目的。</p><p>装饰器有注释的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line">class Person &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  @nonenumerable</span><br><span class="line">  name() &#123; return &#96;$&#123;this.first&#125; $&#123;this.last&#125;&#96; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中，我们一眼就能看出，Person 类是可测试的，而 name 方法是只读和不可枚举的。</p><p>下面是使用 Decorator 写法的组件，看上去一目了然。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  tag: &#39;my-component&#39;,</span><br><span class="line">  styleUrl: &#39;my-component.scss&#39;</span><br><span class="line">&#125;)</span><br><span class="line">export class MyComponent &#123;</span><br><span class="line">  @Prop() first: string;</span><br><span class="line">  @Prop() last: string;</span><br><span class="line">  @State() isVisible: boolean &#x3D; true;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;p&gt;Hello, my name is &#123;this.first&#125; &#123;this.last&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function dec(id)&#123;</span><br><span class="line">  console.log(&#39;evaluated&#39;, id);</span><br><span class="line">  return (target, property, descriptor) &#x3D;&gt; console.log(&#39;executed&#39;, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Example &#123;</span><br><span class="line">    @dec(1)</span><br><span class="line">    @dec(2)</span><br><span class="line">    method()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; evaluated 1</span><br><span class="line">&#x2F;&#x2F; evaluated 2</span><br><span class="line">&#x2F;&#x2F; executed 2</span><br><span class="line">&#x2F;&#x2F; executed 1</span><br></pre></td></tr></table></figure><p>上面代码中，外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行。</p><p>除了注释，装饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。</p><h3 id="3-为什么装饰器不能用于函数？"><a href="#3-为什么装饰器不能用于函数？" class="headerlink" title="3.为什么装饰器不能用于函数？"></a>3.为什么装饰器不能用于函数？</h3><p>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">var add &#x3D; function () &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line">function foo() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，意图是执行后 counter 等于 1，但是实际上结果是 counter 等于 0。因为函数提升，使得实际执行的代码是下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@add</span><br><span class="line">function foo() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var counter;</span><br><span class="line">var add;</span><br><span class="line"></span><br><span class="line">counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">add &#x3D; function () &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果一定要装饰函数，可以采用高阶函数的形式直接执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function doSomething(name) &#123;</span><br><span class="line">  console.log(&#39;Hello, &#39; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingDecorator(wrapped) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    console.log(&#39;Starting&#39;);</span><br><span class="line">    const result &#x3D; wrapped.apply(this, arguments);</span><br><span class="line">    console.log(&#39;Finished&#39;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const wrapped &#x3D; loggingDecorator(doSomething);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
